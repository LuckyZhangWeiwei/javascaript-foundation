function Fn() {
  /*
  new 执行也会把类当作普通函数执行（当然也有类执行的一面）
  1. 创建一个私有栈内存
  2. 形参赋值 & 变量提升
  3. 浏览器创建一个对象处理（这个对象就是当前类的一个新实例），并且让函数中的this指向这个实例对象
     => “构造函数模式中， 方法中的this就是当前类的实例”
  4. 代码执行
  5. 在我们不设置return 的情况下，浏览器会把创建的实例对象默认返回
  */
  this.x = 100;
  this.y = 200;
  this.say = function () {};
}
let f1 = new Fn();
let f2 = new Fn();
/*
类： 函数类型
实例： 对象数据类型
*/

console.log(f1 === f2);
console.log(f1.x === f2.x);
console.log(f1.say === f2.say);

/* 原型及原型链模式：
 1. 每一个函数数据类型的值都有一个天生自带的属性： prototype（原型）, 这个属性的属性值是一个对象
 （用来存储实例的公用属性和方法）
  函数数据类型：普通的函数
                类（自定义类和内置类）
 2. 在prototype 这个对象中，也有一个天生自带的属性 constructor, 这个属性存储的是当前函数本身
 3. 每一个对象数据类型的值， 也有一个天生自带的属性 __proto__, 这个属性指向”所属类的原型prototype“
    普通对象、数组、正则、Math、日期、类数组
    实例也是对象数据类型的值
    函数的原型prototype 也是对象数据类型的值
    函数也是对象数据类型的值
*/
console.log(Fn.prototype.constructor === Fn);
