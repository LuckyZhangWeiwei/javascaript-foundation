/*
闭包作用域
1. 创建一个函数
  开辟一个堆内存
  
  把函数体中的代码当作字符串存储进去
  
  把堆内存的地址赋值给函数名/变量名
  
  函数在哪里创建的，那么它执行的时候所需要查找的上级作用域就是谁
  
2. 函数执行会形成一个全新的私有作用域（执行上下文，私有栈内存）（执行一次 形成一个，多个之间不会产生影响）
  形参赋值 & 变量提升
  
  代码执行（把所属堆内存中的代码字符串拿出来一行行执行）
  
  遇到一个变量，首先看它是否是私有变量（形参和私有作用域中声明的变量是私有变量），是私有的就操作自己的就可以了
  不是私有的则向上一级作用域查找， 一直找到全局作用域为止 -> 作用域链查找机制

  私有变量和外界的变量没有必然的联系，可以理解为被私有栈内存保护起来，这种机制就是 闭包的保护机制

3. 关于堆栈内存释放问题
  函数执行就会形成栈内存， 只要有一个引用类型值，就要有一个堆类型内存值

  堆内存的释放问题
    创建一个引用类型值，就会产生一个堆类型内存值

    如果当前创建的堆内存不被其他东西所占用了，浏览器会在空闲的时候，查找每一个内存的引用状况， 不被占用的都会被回收掉
    例如 let obj = {
      name: "zhufeng"
    }
    
    这个堆内存是不会被释放的， 因为被obj 所引用
    let oop = obj;
    此时obj和oop都占用着对象的堆内存，想要释放堆内存，需要手动解除变量和值的关联 -> obj = null; oop = null;

  栈内存的释放问题
    打开浏览器形成的全局作用域，手动执行函数形成的私有作用域是栈内存， 基于es6 的 let const 形成的块级作用域也是栈内存
    1. 全局作用域释放 关掉页面
    2. 私有栈内存释放 
       1.1 一般情况下，函数只要执行完，形成的私有栈内存就会被释放 （排除死循环）
       例如 function fn() {...}
       fn(); 函数执行形成的栈内存，执行完，栈内存销毁
       1.2 但是一旦栈内存中的某个东西（一般都是堆地址）被私有作用域以外的东西引用，则当前栈内存不能被释放（特点： 私有作用域中的私有变量等信息也被保留下来）
       例如：function x() {
         return function() {// ...}
       }
       let f = x(); x执行会形成一个私有作用域，由于返回了一个函数，则返回函数的堆地址会被f引用，那么当x()执行完后，x() 所形成的作用域（栈内存）不会被释放

       f = null; 则会释放栈内存
    闭包的俩大作用
    1. 保护（私有变量和外界没有必然联系）
    2. 保存 （形成不销毁的栈内存， 里面的变量信息就保存下来了）
*/
{
  var i = 5;
  function fn(i) {
    return function (n) {
      console.log(n + ++i);
    };
  }
  var f = fn(1);
  f(2); // 4
  fn(3)(4); // 8
  fn(5)(6); // 12
  f(7); //
  console.log(i);
}
