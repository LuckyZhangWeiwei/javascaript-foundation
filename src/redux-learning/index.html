<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // import { createStore, combineReducers, applyMiddleware } from "./redux";

      function createStore(reducer, enhancer) {
        // 先处理enhancer
        // 如果enhancer存在并且是函数
        // 我们将createStore作为参数传给他
        // 他应该返回一个新的createStore给我
        // 我再拿这个新的createStore执行，应该得到一个store
        // 直接返回这个store就行
        if (enhancer && typeof enhancer === "function") {
          const newCreateStore = enhancer(createStore);
          const newStore = newCreateStore(reducer);
          return newStore;
        }

        let state; // state记录所有状态
        let listeners = []; // 保存所有注册的回调

        function subscribe(callback) {
          listeners.push(callback); // subscribe就是将回调保存下来
        }

        // dispatch就是先执行reducer修改state
        // 然后将所有的回调拿出来依次执行就行
        function dispatch(action) {
          state = reducer(state, action);

          for (let i = 0; i < listeners.length; i++) {
            const listener = listeners[i];
            listener();
          }
        }

        // getState直接返回state
        function getState() {
          return state;
        }

        // store包装一下前面的方法直接返回
        const store = {
          subscribe,
          dispatch,
          getState,
        };

        return store;
      }

      function combineReducers(reducerMap) {
        const reducerKeys = Object.keys(reducerMap); // 先把参数里面所有的键值拿出来

        // 返回值是一个普通结构的reducer函数
        const reducer = (state = {}, action) => {
          const newState = {};

          for (let i = 0; i < reducerKeys.length; i++) {
            // reducerMap里面每个键的值都是一个reducer，我们把它拿出来运行下就可以得到对应键新的state值
            // 然后将所有reducer返回的state按照参数里面的key组装好
            // 最后再返回组装好的state就行
            const key = reducerKeys[i];
            const currentReducer = reducerMap[key];
            const prevState = state[key];
            newState[key] = currentReducer(prevState, action);
          }

          return newState;
        };

        return reducer;
      }

      function compose(...funcs) {
        return funcs.reduce((a, b) => (...args) => {
          console.group("-------------------------")
          console.log("args:", ...args)
          console.log("b:", b.toString())
          console.log("a:", a.toString())
          console.groupEnd("------------------------")
          a(b(...args));
        });
      }

      // 直接把前面的结构拿过来
      function applyMiddleware(...middlewares) {
        function enhancer(createStore) {
          function newCreateStore(reducer) {
            const store = createStore(reducer);

            // // 将middleware拿过来执行下，传入store
            // // 得到第一层函数
            // const func = middleware(store);

            // // 结构出原始的dispatch
            // const { dispatch } = store;

            // // 将原始的dispatch函数传给func执行
            // // 得到增强版的dispatch
            // const newDispatch = func(dispatch);

            // 多个middleware，先解构出dispatch => newDispatch的结构
            const chain = middlewares.map((middleware) => middleware(store));
            const { dispatch } = store;

            // 用compose得到一个组合了所有newDispatch的函数
            const newDispatchGen = compose(...chain);
            // console.log("newDispatchGen:", newDispatchGen().toString())
            // 执行这个函数得到newDispatch
            const newDispatch = newDispatchGen(dispatch);

            // 返回的时候用增强版的newDispatch替换原始的dispatch
            return { ...store, dispatch: newDispatch };
          }

          return newCreateStore;
        }

        return enhancer;
      }

      /******************************************************* */

      const initMilkState = {
        milk: 0,
      };
      function milkReducer(state = initMilkState, action) {
        switch (action.type) {
          case "PUT_MILK":
            return { ...state, milk: state.milk + action.count };
          case "TAKE_MILK":
            return { ...state, milk: state.milk - action.count };
          default:
            return state;
        }
      }

      const initRiceState = {
        rice: 0,
      };
      function riceReducer(state = initRiceState, action) {
        switch (action.type) {
          case "PUT_RICE":
            return { ...state, rice: state.rice + action.count };
          case "TAKE_RICE":
            return { ...state, rice: state.rice - action.count };
          default:
            return state;
        }
      }

      // 使用combineReducers组合两个reducer
      const reducer = combineReducers({
        milkState: milkReducer,
        riceState: riceReducer,
      });

      // logger是一个中间件，注意返回值嵌了好几层函数
      function logger(store) {
        return function (next) {
          console.log("next1:", next);
          return function (action) {
            console.log("action1:", action);
            console.group(action.type);
            console.info("dispatching", action);
            let result = next(action);
            console.log("next state", store.getState());
            console.groupEnd();
            return result;
          };
        };
      }

      function logger2(store) {
        console.log("logger2");
        return function (next) {
          console.log("next2", next);
          return function (action) {
            console.log("action2:", action);
            let result = next(action);
            console.log("logger2");
            return result;
          };
        };
      }

      let store = createStore(reducer, applyMiddleware(logger, logger2));

      // subscribe其实就是订阅store的变化，一旦store发生了变化，传入的回调函数就会被调用
      // 如果是结合页面更新，更新的操作就是在这里执行
      store.subscribe(() => console.log(store.getState()));

      // 将action发出去就要用dispatch
      store.dispatch({ type: "PUT_MILK", count: 1 }); // milk: 1
      store.dispatch({ type: "PUT_MILK", count: 1 }); // milk: 2
      store.dispatch({ type: "TAKE_MILK", count: 1 }); // milk: 1

      store.dispatch({ type: "PUT_RICE", count: 1 }); // rice: 1
      store.dispatch({ type: "PUT_RICE", count: 1 }); // rice: 2
      store.dispatch({ type: "TAKE_RICE", count: 1 }); // rice: 1
    </script>
  </body>
</html>
